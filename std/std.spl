inline I8_MIN   -128                end
inline I16_MIN  -32768              end
inline I32_MIN  2147483648          end
inline I64_MIN  -461168601842738790 end
inline I8_MAX   128                 end
inline I16_MAX  32768               end
inline I32_MAX  2147483648          end
inline I64_MAX  461168601842738790  end

inline sys_read_nr     0  end
inline sys_write_nr    1  end
inline sys_open_nr     2  end
inline sys_close_nr    3  end
inline sys_stat_nr     4  end
inline sys_fstat_nr    5  end
inline sys_lstat_nr    6  end
inline sys_poll_nr     7  end
inline sys_lseek_nr    8  end
inline sys_mmap_nr     9  end
inline sys_mprotect_nr 10 end
inline sys_munmap_nr   11 end
inline sys_brk_nr      12 end
inline sys_exit_nr     60 end

inline stdin        0 end
inline stdout       1 end
inline stderr       2 end

inline READ                0   end # O_RDONLY  
inline WRITE               1   end # O_WRONLY
inline READ_WRITE          2   end # O_RDWR
inline WRITE_CREATE        65  end # O_WRONLY | O_CREAT
inline WRITE_CREATE_TRUNC  577 end # O_WRONLY | O_CREAT | O_TRUNC

inline str_to_cstr swap pop        end   # ( len addr -- addr ) Removes len, assumes null-terminated
inline cstr_to_str dup strlen swap end   # ( addr -- len addr ) Adds length of string to stack behind ptr

# ( len addr -- )
inline print
    # result is syscal is pushed to stack, which is popped
    stdout sys_write_nr syscall4 pop
end

# ( len addr -- )
inline println
    print
    "\n" print
end

# ( len addr -- )
inline eprint
    # result is syscal is pushed to stack, which is popped
    stderr sys_write_nr syscall4 pop
end

# ( len addr -- )
inline eprintln
    eprint
    "\n" eprint
end

memory heap_ptr 8 end  # Points to the next free byte

# ( -- )
# Call this ONCE at the start of your program
proc heap_init do
    # syscall brk(0) returns the current program break
    0 sys_brk_nr syscall2 
    heap_ptr swap @8
end

# ( size -- addr )
proc malloc do
    # Get current heap pointer and calculate new address
    heap_ptr !8 over +
    
    # Request memory from OS
    dup sys_brk_nr syscall2
    
    # Update global pointer
    # TODO: Check for fail, pointer should be 0
    heap_ptr swap @8
    
    # Return the old pointer, size is dropped
    swap pop
end

# ( size addr -- len )
proc scan do    
    # File Descriptor (0 = stdin)
    # [ size addr 0 ]
    stdin           # File Descriptor (0 = stdin)

    # Syscall ID (0 = read)
    # [size addr 0 stdin]
    0       
    
    syscall4    # This consumes the 4 items and returns bytes read in RAX
end

# ( index -- addr )
proc get_arg do
    8 * # Each pointer is 8 bytes
    argv !8      # Get the base address of the argv array
    +            # Add the offset
    !8           # Load the address of the string
end

# ( size addr fd -- bytes_read )
proc sys_read do
    sys_read_nr       # sys_read ID
    syscall4
end

# ( count addr fd -- bytes_written )
proc sys_write do
    sys_write_nr       # sys_write ID
    syscall4
end

# ( flags file_addr -- fd )
# flags: 0 for read, 1 for write, 2 for rw
proc sys_open do
    sys_open_nr       # sys_open ID
    syscall3
end

# ( fd -- result )
proc sys_close do
    sys_close_nr       # sys_close ID
    syscall2
end

# ( status -- )
proc exit do
    sys_exit_nr syscall1
end

# ( addr index char -- )
proc replace_char do
    rot rot swap    # [INDEX, ADDR, ASCII CHAR]
    +               # [ADDR + INDEX, ASCII CHAR]
    swap            # [ASCII CHAR, ADDR + INDEX]
    @1              # []
end 

# ( addr -- len )
proc strlen do
    dup             # [ addr, addr ]
    while dup !1 0 != do
        1 +         # Increment the pointer
    end
    # Stack: [ start_addr, end_ptr ]
    over -          # [ start_addr, len ]
    swap pop        # Remove start_addr, leaving only len
end

# ( len1 addr1 len2 addr2 -- bool )
proc streq do
    if 3 pick 2 pick != do
        # String do not have same length
        pop pop pop pop 0
    else        
        swap pop rot      # [ addr1 addr2 len1 ]
        
        # 3. Comparison Loop
        # Invariant: [ addr1 addr2 len ]
        while dup 0 > do
            # Compare characters
            2 pick !1   # Load char from addr1
            2 pick !1   # Load char from addr2
            if != do
                # Mismatch found!
                pop pop pop 0
                return 
            end
        
            1 -         # Decrement length
            rot 1 +     # Increment addr1
            rot 1 +     # Increment addr2
            rot         # Restore order: [ addr1 addr2 len ]
        end
        
        pop pop pop 1
    end
end


# ( len addr index -- char )
proc index_str do
    # Stack: [ length, address, index ]
    
    #  Bounds Check (index < length)
    if over over < do
        swap        # [ length, index, address ]
        rot pop    # [ index, address ]
        +           # [ address + index ]
        !1          # Load 1 byte from that address
    else
        "Error: Index out of bounds\n" eprint
        pop pop pop 0
    end
end

# ( len addr - int )
proc atoi do
    # Setup: [ addr len 0 ]
    swap 0          
    
    while over 0 > do
        # Invariant: [ addr len acc ]
        
        # 1. Get Digit
        rot             # [ len acc addr ]
        dup !1 48 -     # [ len acc addr digit ]
        
        # 2. Add to Acc
        rot             # [ len addr digit acc ]
        10 * +          # [ len addr new_acc ]
        
        # 3. Adjust Pointers
        swap 1 +        # [ len new_acc new_addr ]
        rot 1 -         # [ new_acc new_addr new_len ]
        
        # 4. Restore: [ new_addr new_len new_acc ]
        rot             # [ new_addr new_len new_acc ]
    end
    
    # Cleanup: [ addr len acc ]
    rot rot pop pop
end

# ( addr int -- len start_addr )
proc itoa do
    # Check for Zero
    if dup 0 = do
        # Stack: [ 0 end_ptr ]
        1 -                     # Move back one spot: [ 0 ptr ]
        dup 48 @1               # Store '0' at ptr
        
        # Cleanup to match return signature
        swap pop                # [ ptr ]
        1 swap                  # [ 1 ptr ]

        return
    end
    
    swap 32 + swap      # [ end_ptr int ]
    over 0 @1           # Add null terminator at end_ptr

    # Conversion Loop
    over while over 0 > do
        # Move pointer back
        1 -                     # [ end_ptr int new_ptr ]

        # Calculate char from digit: (int % 10) + 48
        over 10 % 48 +          # [ end_ptr int new_ptr char ]
        
        # Store char at new_ptr
        over swap @1            # [ end_ptr int new_ptr ]
        
        # Divide integer
        swap 10 / swap          # [ end_ptr new_int new_ptr ]
    end
    
    # Remove loop iterator
    swap pop                    # [ end_ptr start_addr ]

    # Calculate length (end_ptr - start_addr)
    over over -                 # [ end_ptr start_addr len ]
    rot pop swap                # [ len start_addr ]
end
