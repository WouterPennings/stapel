inline I8_MIN   -128                end
inline I16_MIN  -32768              end
inline I32_MAX  2147483648          end
inline I64_MIN  -461168601842738790 end
inline I8_MAX   128                 end
inline I16_MAX  32768               end
inline I32_MAX  2147483648          end
inline I64_MAX  461168601842738790  end

inline STDIN        0 end
inline STDOUT       1 end
inline STDERR       2 end

inline READ                0   end # O_RDONLY  
inline WRITE               1   end # O_WRONLY
inline READ_WRITE          2   end # O_RDWR
inline WRITE_CREATE        65  end # O_WRONLY | O_CREAT
inline WRITE_CREATE_TRUNC  577 end # O_WRONLY | O_CREAT | O_TRUNC

inline to_CSTR swap pop end   # Removes the len from the stack, only null-terminated

# INPUT  [ len addr ]
# OUTPUT [ ]
proc print do
    # result is syscal is pushed to stack, which is popped
    STDOUT 1 syscall4 pop
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc println do
    print
    "\n" print
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc eprint do
    # result is syscal is pushed to stack, which is popped
    STDERR 1 syscall4 pop
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc eprintln do
    STDERR 1 syscall4 pop
    "\n" STDERR 1 syscall 4 pop
end

# INPUT  [ size addr ]
# OUTPUT [ len ]
proc scan do    
    # File Descriptor (0 = stdin)
    # [ size addr 0 ]
    STDIN           # File Descriptor (0 = stdin)

    # Syscall ID (0 = read)
    # [size addr 0 stdin]
    0       
    
    syscall4    # This consumes the 4 items and returns bytes read in RAX
end

# INPUT:  [ index ]
# OUTPUT: [ addr ]
proc get_arg do
    8 *          # Each pointer is 8 bytes
    argv !8      # Get the base address of the argv array
    +            # Add the offset
    !8           # Load the address of the string
end

# INPUT  [ flag file_addr ]
# OUTPUT [ fd ]
# flags: 0 for read, 1 for write, 2 for rw
proc sys_open do
    2       # sys_open ID
    syscall3
end

# INPUT  [ size addr fd ]
# OUTPUT [ bytes_read ]
proc sys_read do
    0       # sys_read ID
    syscall4
end

# INPUT  [ count addr fd ]
# OUTPUT [ bytes_written ]
proc sys_write do
    1       # sys_write ID
    syscall4
end

# INPUT  [ fd ]
# OUTPUT [ result ]
proc sys_close do
    3       # sys_close ID
    syscall2
end

# INPUT  [ addr index char ]
# OUTPUT [ ]
proc replace_char do
    rot rot swap    # [INDEX, ADDR, ASCII CHAR]
    +               # [ADDR + INDEX, ASCII CHAR]
    swap            # [ASCII CHAR, ADDR + INDEX]
    @1              # []
end 

# INPUT  [ addr ]
# OUTPUT [ len ]
proc strlen do
    dup             # [ addr, addr ]
    while dup !1 0 != do
        1 +         # Increment the pointer
    end
    # Stack: [ start_addr, end_ptr ]
    over -          # [ start_addr, len ]
    swap pop        # Remove start_addr, leaving only len
end


# INPUT:  [ len addr index ]
# OUTPUT: [ char ]
proc index_str do
    # Stack: [ length, address, index ]
    
    #  Bounds Check (index < length)
    if over over < do
        swap        # [ length, index, address ]
        rot drop    # [ index, address ]
        +           # [ address + index ]
        !1          # Load 1 byte from that address
    else
        "Error: Index out of bounds\n" eprint
        drop drop drop 0
    end
end