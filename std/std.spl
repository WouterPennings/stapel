inline I8_MIN   -128                end
inline I16_MIN  -32768              end
inline I32_MIN  2147483648          end
inline I64_MIN  -461168601842738790 end
inline I8_MAX   128                 end
inline I16_MAX  32768               end
inline I32_MAX  2147483648          end
inline I64_MAX  461168601842738790  end

inline sys_read_nr     0  end
inline sys_write_nr    1  end
inline sys_open_nr     2  end
inline sys_close_nr    3  end
inline sys_stat_nr     4  end
inline sys_fstat_nr    5  end
inline sys_lstat_nr    6  end
inline sys_poll_nr     7  end
inline sys_lseek_nr    8  end
inline sys_mmap_nr     9  end
inline sys_mprotect_nr 10 end
inline sys_munmap_nr   11 end
inline sys_brk_nr      12 end
inline sys_exit_nr     60 end

inline stdin        0 end
inline stdout       1 end
inline stderr       2 end

inline READ                0   end # O_RDONLY  
inline WRITE               1   end # O_WRONLY
inline READ_WRITE          2   end # O_RDWR
inline WRITE_CREATE        65  end # O_WRONLY | O_CREAT
inline WRITE_CREATE_TRUNC  577 end # O_WRONLY | O_CREAT | O_TRUNC

inline to_CSTR swap pop end   # ( len addr -- addr ) Removes len, assumes null-terminated

# ( len addr -- )
inline print
    # result is syscal is pushed to stack, which is popped
    stdout sys_write_nr syscall4 pop
end

# ( len addr -- )
inline println
    print
    "\n" print
end

# ( len addr -- )
inline eprint
    # result is syscal is pushed to stack, which is popped
    stderr sys_write_nr syscall4 pop
end

# ( len addr -- )
inline eprintln
    eprint
    "\n" eprint
end

memory heap_ptr 8 end  # Points to the next free byte

# ( -- )
# Call this ONCE at the start of your program
proc heap_init do
    # syscall brk(0) returns the current program break
    0 sys_brk_nr syscall2 
    heap_ptr swap @8
end

# ( size -- addr )
proc malloc do
    # Get current heap pointer and calculate new address
    heap_ptr !8 over +
    
    # Request memory from OS
    dup sys_brk_nr syscall2
    
    # Update global pointer
    # TODO: Check for fail, pointer should be 0
    heap_ptr swap @8
    
    # Return the old pointer, size is dropped
    swap pop
end

# ( size addr -- len )
proc scan do    
    # File Descriptor (0 = stdin)
    # [ size addr 0 ]
    stdin           # File Descriptor (0 = stdin)

    # Syscall ID (0 = read)
    # [size addr 0 stdin]
    0       
    
    syscall4    # This consumes the 4 items and returns bytes read in RAX
end

# ( index -- addr )
proc get_arg do
    8 * # Each pointer is 8 bytes
    argv !8      # Get the base address of the argv array
    +            # Add the offset
    !8           # Load the address of the string
end

# ( size addr fd -- bytes_read )
proc sys_read do
    sys_read_nr       # sys_read ID
    syscall4
end

# ( count addr fd -- bytes_written )
proc sys_write do
    sys_write_nr       # sys_write ID
    syscall4
end

# ( flags file_addr -- fd )
# flags: 0 for read, 1 for write, 2 for rw
proc sys_open do
    sys_open_nr       # sys_open ID
    syscall3
end

# ( fd -- result )
proc sys_close do
    sys_close_nr       # sys_close ID
    syscall2
end

# ( status -- )
proc exit do
    sys_exit_nr syscall1
end

# ( addr index char -- )
proc replace_char do
    rot rot swap    # [INDEX, ADDR, ASCII CHAR]
    +               # [ADDR + INDEX, ASCII CHAR]
    swap            # [ASCII CHAR, ADDR + INDEX]
    @1              # []
end 

# ( addr -- len )
proc strlen do
    dup             # [ addr, addr ]
    while dup !1 0 != do
        1 +         # Increment the pointer
    end
    # Stack: [ start_addr, end_ptr ]
    over -          # [ start_addr, len ]
    swap pop        # Remove start_addr, leaving only len
end

# ( len addr index -- char )
proc index_str do
    # Stack: [ length, address, index ]
    
    #  Bounds Check (index < length)
    if over over < do
        swap        # [ length, index, address ]
        rot pop    # [ index, address ]
        +           # [ address + index ]
        !1          # Load 1 byte from that address
    else
        "Error: Index out of bounds\n" eprint
        pop pop pop 0
    end
end
