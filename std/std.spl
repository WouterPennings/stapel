inline I8_MIN   -128                end
inline I16_MIN  -32768              end
inline I32_MAX  2147483648          end
inline I64_MIN  -461168601842738790 end
inline I8_MAX   128                 end
inline I16_MAX  32768               end
inline I32_MAX  2147483648          end
inline I64_MAX  461168601842738790  end

inline sys_read     0  end
inline sys_write    1  end
inline sys_open     2  end
inline sys_open     3  end
inline sys_stat     4  end
inline sys_fstat    5  end
inline sys_lstat    6  end
inline sys_poll     7  end
inline sys_lseek    8  end
inline sys_mmap     9  end
inline sys_mprotect 10 end
inline sys_munmap   11 end
inline sys_brk      12 end

inline stdin        0 end
inline stdout       1 end
inline stderr       2 end

inline READ                0   end # O_RDONLY  
inline WRITE               1   end # O_WRONLY
inline READ_WRITE          2   end # O_RDWR
inline WRITE_CREATE        65  end # O_WRONLY | O_CREAT
inline WRITE_CREATE_TRUNC  577 end # O_WRONLY | O_CREAT | O_TRUNC

inline to_CSTR swap pop end   # Removes the len from the stack, only null-terminated

# INPUT  [ len addr ]
# OUTPUT [ ]
proc print do
    # result is syscal is pushed to stack, which is popped
    stdout sys_write syscall4 pop
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc println do
    print
    "\n" print
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc eprint do
    # result is syscal is pushed to stack, which is popped
    stderr sys_write syscall4 pop
end

# INPUT  [ len addr ]
# OUTPUT [ ]
proc eprintln do
    eprint
    "\n" eprint
end

memory heap_ptr 8 end  # Points to the next free byte

# Call this ONCE at the start of your program
proc heap_init do
    # syscall brk(0) returns the current program break
    0 sys_brk syscall2 
    heap_ptr swap @8
end

# INPUT:  [ size ]
# OUTPUT: [ addr ]
proc malloc do
    # Get current heap pointer and calculate new address
    heap_ptr !8 over +
    
    # Request memory from OS
    dup sys_brk syscall2
    
    # Update global pointer
    # TODO: Check for fail, pointer should be 0
    heap_ptr swap @8
    
    # Return the old pointer, size is dropped
    swap pop
end


# INPUT  [ size addr ]
# OUTPUT [ len ]
proc scan do    
    # File Descriptor (0 = stdin)
    # [ size addr 0 ]
    stdin           # File Descriptor (0 = stdin)

    # Syscall ID (0 = read)
    # [size addr 0 stdin]
    0       
    
    syscall4    # This consumes the 4 items and returns bytes read in RAX
end

# INPUT:  [ index ]
# OUTPUT: [ addr ]
proc get_arg do
    8 *          # Each pointer is 8 bytes
    argv !8      # Get the base address of the argv array
    +            # Add the offset
    !8           # Load the address of the string
end

# INPUT  [ size addr fd ]
# OUTPUT [ bytes_read ]
proc sys_read do
    sys_read       # sys_read ID
    syscall4
end

# INPUT  [ count addr fd ]
# OUTPUT [ bytes_written ]
proc sys_write do
    sys_write       # sys_write ID
    syscall4
end

# INPUT  [ flag file_addr ]
# OUTPUT [ fd ]
# flags: 0 for read, 1 for write, 2 for rw
proc sys_open do
    sys_open       # sys_open ID
    syscall3
end

# INPUT  [ fd ]
# OUTPUT [ result ]
proc sys_close do
    sys_close       # sys_close ID
    syscall2
end

# INPUT  [ addr index char ]
# OUTPUT [ ]
proc replace_char do
    rot rot swap    # [INDEX, ADDR, ASCII CHAR]
    +               # [ADDR + INDEX, ASCII CHAR]
    swap            # [ASCII CHAR, ADDR + INDEX]
    @1              # []
end 

# INPUT  [ addr ]
# OUTPUT [ len ]
proc strlen do
    dup             # [ addr, addr ]
    while dup !1 0 != do
        1 +         # Increment the pointer
    end
    # Stack: [ start_addr, end_ptr ]
    over -          # [ start_addr, len ]
    swap pop        # Remove start_addr, leaving only len
end


# INPUT:  [ len addr index ]
# OUTPUT: [ char ]
proc index_str do
    # Stack: [ length, address, index ]
    
    #  Bounds Check (index < length)
    if over over < do
        swap        # [ length, index, address ]
        rot drop    # [ index, address ]
        +           # [ address + index ]
        !1          # Load 1 byte from that address
    else
        "Error: Index out of bounds\n" eprint
        drop drop drop 0
    end
end