inline sys_read_nr     0  end
inline sys_write_nr    1  end
inline sys_open_nr     2  end
inline sys_close_nr    3  end
inline sys_stat_nr     4  end
inline sys_fstat_nr    5  end
inline sys_lstat_nr    6  end
inline sys_poll_nr     7  end
inline sys_lseek_nr    8  end
inline sys_mmap_nr     9  end
inline sys_mprotect_nr 10 end
inline sys_munmap_nr   11 end
inline sys_brk_nr      12 end
inline sys_exit_nr     60 end

inline stdin        0 end
inline stdout       1 end
inline stderr       2 end

inline READ                0   end # O_RDONLY  
inline WRITE               1   end # O_WRONLY
inline READ_WRITE          2   end # O_RDWR
inline WRITE_CREATE        65  end # O_WRONLY | O_CREAT
inline WRITE_CREATE_TRUNC  577 end # O_WRONLY | O_CREAT | O_TRUNC

inline str_to_cstr swap pop        end   # ( len addr -- addr ) Removes len, assumes null-terminated
inline cstr_to_str dup strlen swap end   # ( addr -- len addr ) Adds length of string to stack behind ptr

# ( len addr -- )
proc print do
    # result is syscal is pushed to stack, which is popped
    stdout sys_write_nr syscall4 pop
end

# ( len addr -- )
proc println do
    print
    "\n" print
end

# ( size addr fd -- bytes_read )
proc sys_read do
    sys_read_nr       # sys_read ID
    syscall4
end

memory char_buffer 1 end # 1-byte buffer
# ( fd -- byte (or -1 if EOF) )
proc read_byte do
    char_buffer # [ fd addr ]
    1           # [ fd addr 1 ] size (1 byte)
    swap rot    # [ 1 addr fd ]
    sys_read    # Returns bytes read (1 or 0)
end

# ( count addr fd -- bytes_written )
proc sys_write do
    sys_write_nr       # sys_write ID
    syscall4
end

# ( flags file_addr -- fd )
# flags: 0 for read, 1 for write, 2 for rw
proc sys_open do
    sys_open_nr       # sys_open ID
    syscall3
end

# ( status -- )
proc exit do
    sys_exit_nr syscall1
end

memory malloc_heap_ptr 8 end  # Points to the next free byte
# Call this ONCE at the start of your program
# ( -- )
proc malloc_heap_init do
    0 sys_brk_nr syscall2 
    malloc_heap_ptr swap @8
end

# ( size -- addr )
proc malloc do
    # Get current heap pointer and calculate new address
    malloc_heap_ptr !8 over +
    
    # Request memory from OS
    dup sys_brk_nr syscall2
    
    # Update global pointer
    # TODO: Check for fail, pointer should be 0
    malloc_heap_ptr swap @8
    
    # Return the old pointer, size is dropped
    swap pop
end

# ( addr -- len )
proc strlen do
    dup             # [ addr, addr ]
    while dup !1 0 != do
        1 +         # Increment the pointer
    end
    # Stack: [ start_addr, end_ptr ]
    over -          # [ start_addr, len ]
    swap pop        # Remove start_addr, leaving only len
end

# ( len1 addr1 len2 addr2 -- bool )
proc streq do
    if 3 pick 2 pick != do
        # String do not have same length
        pop pop pop pop 0
    else        
        swap pop rot      # [ addr1 addr2 len1 ]
        
        # 3. Comparison Loop
        # Invariant: [ addr1 addr2 len ]
        while dup 0 > do
            # Compare characters
            2 pick !1   # Load char from addr1
            2 pick !1   # Load char from addr2
            if != do
                # Mismatch found!
                pop pop pop 0
                return 
            end
        
            1 -         # Decrement length
            rot 1 +     # Increment addr1
            rot 1 +     # Increment addr2
            rot         # Restore order: [ addr1 addr2 len ]
        end
        
        pop pop pop 1
    end
end

# ( len addr - int )
proc atoi do
    # Setup: [ addr len 0 ]
    swap 0          
    
    while over 0 > do
        # Invariant: [ addr len acc ]
        
        # 1. Get Digit
        rot             # [ len acc addr ]
        dup !1 48 -     # [ len acc addr digit ]
        
        # 2. Add to Acc
        rot             # [ len addr digit acc ]
        10 * +          # [ len addr new_acc ]
        
        # 3. Adjust Pointers
        swap 1 +        # [ len new_acc new_addr ]
        rot 1 -         # [ new_acc new_addr new_len ]
        
        # 4. Restore: [ new_addr new_len new_acc ]
        rot             # [ new_addr new_len new_acc ]
    end
    
    # Cleanup: [ addr len acc ]
    rot rot pop pop
end

# ( addr int -- len start_addr )
proc itoa do
    # Check for Zero
    if dup 0 = do
        # Stack: [ 0 end_ptr ]
        1 -                     # Move back one spot: [ 0 ptr ]
        dup 48 @1               # Store '0' at ptr
        
        # Cleanup to match return signature
        swap pop                # [ ptr ]
        1 swap                  # [ 1 ptr ]

        return
    end
    
    swap 32 + swap      # [ end_ptr int ]
    over 0 @1           # Add null terminator at end_ptr

    # Conversion Loop
    over while over 0 > do
        # Move pointer back
        1 -                     # [ end_ptr int new_ptr ]

        # Calculate char from digit: (int % 10) + 48
        over 10 % 48 +          # [ end_ptr int new_ptr char ]
        
        # Store char at new_ptr
        over swap @1            # [ end_ptr int new_ptr ]
        
        # Divide integer
        swap 10 / swap          # [ end_ptr new_int new_ptr ]
    end
    
    # Remove loop iterator
    swap pop                    # [ end_ptr start_addr ]

    # Calculate length (end_ptr - start_addr)
    over over -                 # [ end_ptr start_addr len ]
    rot pop swap                # [ len start_addr ]
end

# ( len addr -- )
inline add_instruction 
    "    " print print
end

# ( len addr -- )
inline add_instruction_endl
    "    " print println
end

# ( len addr -- )
inline add_proc 
    "proc_" print print ":"println
end

# ( -- )
proc dump_stack do
    "======================" println
    "Stack size: " print size put
    while size 0 != do
        " - " print put
    end
    "======================" println
end

# Every 16 bytes
#   - First 8 bytes: instruction type
#   - Second 8 bytes: operant to instruction data or ptr to more complex operation data.
inline END_OF_PROGRAM    0  end # no operant ofc, basically a null-terminator
inline put_op            1  end # No operant 
inline push_op           2  end # i64 (TODO: String, to ptr)
inline infixOperators_op 3  end # ptr
inline while_op          4  end # ptr
inline if_op             5  end # ptr
inline pop_op            6  end # No operant
inline dup_op            7  end # No operant
inline over_op           8  end # No operant
inline pick_op           9  end # No operant
inline swap_op           10 end # No operant
inline rot_op            11 end # No operant
inline size_op           12 end # No operant
inline load_op           14 end # i64
inline store_op          15 end # i64
inline identifier_op     16 end # ptr
inline return_op         18 end # No operant
inline syscall_op        19 end # u8

# Infix operator codes
inline infix_add  1   end # +    -->  add
inline infix_min  2   end # -    -->  sub
inline infix_mul  3   end # *    -->  imul
inline infix_div  4   end # /    -->  idiv
inline infix_mod  5   end # %    -->  idiv
inline infix_eq   6   end # =    -->  sete
inline infix_nq   7   end # !=   -->  setne
inline infix_lt   8   end # <    -->  setl
inline infix_gt   9   end # >    -->  setg
inline infix_ge   10  end # >=   -->  cmovge
inline infix_le   11  end # <=   -->  cmovle
inline infix_and  12  end # and  -->  and
inline infix_or   13  end # oo   -->  or

inline start_asm_x86_64 "src/start_asm_x86_64.asm" end
#( -- )
# fd char 1
proc include_asm_start do
    READ start_asm_x86_64 swap pop sys_open # [ fd ]
    
    1 while 0 > do
        dup read_byte         # [ fd byte ]
        1 char_buffer print   # [ fd ] Prints actual byte on screen 
    end

    pop # Pops file descriptor off the stack
end

# Compiles a block, from procedues, if statement, etc. Expects pointer to memory buffer of block
# ( ptr --  )
proc compile_block do
    # This while loop is basically like this:
    # int i = 0
    # while (block + i * 16 != 0) {
    #     int* ip = block + i * 16;    
    # }
    # `int i` is the iterator over the instructions with which the actual pointer is calculated

    0 while dup 16 * 2 pick + !8 END_OF_PROGRAM != do
        dup 16 * 2 pick + !8

        if   dup put_op = do
            "; --- Put ---"  add_instruction_endl
	        "pop rdi"        add_instruction_endl
	        "call print_i64" add_instruction_endl
        elif dup push_op = do
            "; --- Push ---" add_instruction_endl 
            # Reads operant of push int
	        "push " add_instruction over 16 * 3 pick + 8 + !8 put
        elif dup infixOperators_op = do
            "; --- Infix ---" add_instruction_endl 
            # Puts code for infix operator on top of stack
            over 16 * 3 pick + 8 + !8 # ( block op_code -- block op_code infix_code )
            
            "pop rbx" add_instruction_endl
            "pop rax" add_instruction_endl

            if   dup infix_add = do
                "add rax, rbx"  add_instruction_endl
                "push rax"      add_instruction_endl
            elif dup infix_min = do
                "sub rax, rbx"  add_instruction_endl
                "push rax"      add_instruction_endl
            elif dup infix_mul = do
                "xor rdx, rdx"  add_instruction_endl
                "imul rdx"      add_instruction_endl
                "push rax"      add_instruction_endl
            elif dup infix_div = do
                "xor rdx, rdx"  add_instruction_endl
                "idiv rdx"      add_instruction_endl
                "push rax"      add_instruction_endl
            elif dup infix_mod = do
                "xor rdx, rdx"  add_instruction_endl
                "cqo"           add_instruction_endl
                "idiv rbx"      add_instruction_endl
                "push rdx"      add_instruction_endl
            elif dup infix_eq = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "sete cl"       add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_nq = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "setne cl"      add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_lt = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "setl cl"       add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_gt = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "setg cl"       add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_ge = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "cmovge cl"     add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_le = do
                "xor rcx, rcx"  add_instruction_endl
                "cmp rax, rbx"  add_instruction_endl
                "cmovle cl"     add_instruction_endl
                "push rcx"      add_instruction_endl
            elif dup infix_and = do
                "cmp rax, 0"    add_instruction_endl
                "setne al"      add_instruction_endl
                "cmp rbx, 0"    add_instruction_endl
                "setne bl"      add_instruction_endl
                "and al, bl"    add_instruction_endl
                "movzx rax, al" add_instruction_endl
                "push rax"      add_instruction_endl
            elif dup infix_or = do
                "or rax, rbx"   add_instruction_endl
                "push rax"      add_instruction_endl
            else "ERROR: Infix operator does not exist: " print put 1 exit end
                
            pop # Pops infix code of stack
        elif dup while_op = do
            "TODO: operation type 'while_op' has not been implemented for codegen" println 1 exit
        elif dup if_op = do
            "TODO: operation type 'if_op' has not been implemented for codegen" println 1 exit
        elif dup pop_op = do
            "; --- Pop ---"  add_instruction_endl
            "pop rax"        add_instruction_endl
        elif dup dup_op = do
            "; --- Dup ---"  add_instruction_endl
            "pop rax"        add_instruction_endl
            "push rax"       add_instruction_endl
            "push rax"       add_instruction_endl
        elif dup over_op = do
            "; --- Over ---"  add_instruction_endl
            "pop rax"         add_instruction_endl
            "pop rbx"         add_instruction_endl
            "push rbx"        add_instruction_endl
            "push rax"        add_instruction_endl
            "push rbx"        add_instruction_endl
        elif dup pick_op = do
            "; --- Pick ---"       add_instruction_endl
            "pop rax"              add_instruction_endl         
            "shl rax, 3"           add_instruction_endl # rax = N * 8 (shift left by 3 is same as * 8)
            "mov rbx, [rsp + rax]" add_instruction_endl # Get the value at that memory offset
            "push rbx"             add_instruction_endl     
        elif dup swap_op = do
            "; --- Swap ---"  add_instruction_endl
            "pop rax"         add_instruction_endl
            "pop rbx"         add_instruction_endl
            "push rax"        add_instruction_endl
            "push rbx"        add_instruction_endl
        elif dup rot_op = do
            "; --- Rot ---"  add_instruction_endl
            "pop rcx"        add_instruction_endl
            "pop rbx"        add_instruction_endl
            "pop rax"        add_instruction_endl
            "push rbx"       add_instruction_endl
            "push rcx"       add_instruction_endl
            "push rax"       add_instruction_endl
        elif dup size_op = do
            "; --- Size ---"            add_instruction_endl
            "mov rax, rsp"              add_instruction_endl
            "sub rax, [ori_stack_ptr]"  add_instruction_endl
            "neg rax"                   add_instruction_endl
            "shr rax, 3"                add_instruction_endl # Divide by 8 bytes
            "push rax"                  add_instruction_endl        
        elif dup load_op = do
            "; --- Load ---"  add_instruction_endl
            "pop rax"         add_instruction_endl
            "xor rbx, rbx"    add_instruction_endl

            # Getting operant of load_op
            over 16 * 3 pick + 8 + !8

            if   dup 1 = do "mov bl, [rax]"     add_instruction_endl
            elif dup 2 = do "mov bx, [rax]"     add_instruction_endl
            elif dup 4 = do "mov ebx, [rax]"    add_instruction_endl
            elif dup 8 = do "mov rbx, [rax]"    add_instruction_endl
            else "ERROR: unsupported load size" print 1 exit end

            "push rbx" add_instruction_endl

            pop # Pops size of load of the stack
        elif dup store_op = do
            "; --- Store ---"  add_instruction_endl
            "pop rbx"          add_instruction_endl
            "pop rax"          add_instruction_endl

            # Getting operant of store_op
            over 16 * 3 pick + 8 + !8

            if   dup 1 = do "mov [rax], bl"      add_instruction_endl
            elif dup 2 = do "mov [rax], bx"      add_instruction_endl
            elif dup 4 = do "mov [rax], ebx"     add_instruction_endl
            elif dup 8 = do "mov [rax], rbx"     add_instruction_endl
            else "ERROR: unsupported store size" print 1 exit end

            pop # Pops size of store of the stack
        elif dup identifier_op = do
            "; --- Identifier ---"  add_instruction_endl
            "TODO: operation type has not been implemented for codegen: " print identifier_op put 1 exit
        elif dup return_op = do
            "; --- Return ---"               add_instruction_endl
            "test r13, r13"                  add_instruction_endl
            "jz stack_underflow"             add_instruction_endl
            "mov rdx, [ret_stack + r13 * 8]" add_instruction_endl
            "dec r13"                        add_instruction_endl
            "jmp rdx"                        add_instruction_endl
        elif dup syscall_op = do
            "; --- Syscall ---"  add_instruction_endl
            over 16 * 3 pick + 8 + !8
            if   dup 1 = do
                "pop rax" add_instruction_endl
            elif dup 2 = do
                "pop rax\n    pop rdi" add_instruction_endl
            elif dup 3 = do
                "pop rax\n    pop rdi\n    pop rsi" add_instruction_endl
            elif dup 4 = do
                "pop rax\n    pop rdi\n    pop rsi\n    pop rdx" add_instruction_endl
            elif dup 5 = do
                "pop rax\n    pop rdi\n    pop rsi\n    pop rdx\n    pop r10" add_instruction_endl
            elif dup 6 = do
                "pop rax\n    pop rdi\n    pop rsi\n    pop rdx\n    pop r10\n    pop r9" add_instruction_endl
            elif dup 7 = do
                "pop rax\n    pop rdi\n    pop rsi\n    pop rdx\n    pop r10\n    pop r9\n    pop r8" add_instruction_endl
            else
                "ERROR: syscalls need to have between 1 and 7 arguments" println 1 exit
            end

            pop     # Pops the syscall argument count of the stack

            "syscall"  add_instruction_endl
            "push rax" add_instruction_endl
        else
            "UNKNOWN: This is an unknown operation type: " print put 1 exit
        end

        pop     # Pops the instruction type of the stack
        1 +     # Increase block ip
    end

    pop pop     # Pops and pointer to block of the stack
end

memory block      1024 end

# Each procedure is 2 ptr's (16 bytes total)
#   - 1 ptr to identifier (string)
#   - 1 ptr to block of procedure
memory procedures 1024 end 
# Each memory is 1 ptr and a size (16 bytes total)
#   - 1 ptr to identifier (string)
#   - 1 u32 for size of memory
memory memories   1024 end
memory inlines    1024 end

# ( -- )
proc compile_x86_64 do
    # This while loop is basically like this:
    # int i = 0
    # while (procedure + i * 16 != 0) {
    #     int* ip = procedure + i * 16;    
    # }
    # `int i` is the iterator over the procedures with which the actual pointer is calculated
    procedures 0 # ptr & iterator
    while dup 16 * procedures + !8 0 != do
        dup 16 * 2 pick + !8      # [ ptr iter ptr(ident) ]
        over 16 * 3 pick + 8 + !8 # [ ptr(procs) iter ptr(ident) ptr(block)]
        swap cstr_to_str          # [ ptr(procs) iter ptr(block) len ptr(ident) ]

    
        over over # Copying string ptr and len on top of string
        if "main" streq 1 = do
            # Adds label for the upcoming compiled procedure
            add_proc      # [ ptr(procs) iter ptr(block) ]
            compile_block # [ ptr(procs) iter ] 

            "; === GLOBAL EXIT ===\n" add_instruction_endl
            "mov rax, 60" add_instruction_endl
            "mov rdi, 0"  add_instruction_endl
            "syscall\n"   add_instruction_endl
        else
            # Adds label for the upcoming compiled procedure
            add_proc      # [ ptr(procs) iter ptr(block) ]
            compile_block # [ ptr(procs) iter ] 
        end

        # Increase the procedure iterator
        1 +
    end
    pop pop # Pop ptr to procedures and iterator of the stack

    "section .bss" println
    # This while loop is basically like this:
    # int i = 0
    # while (memory + i * 16 != 0) {
    #     int* ip = memory + i * 16;    
    # }
    # `int i` is the iterator over the memories with which the actual pointer is calculated
    memories 0 # ptr & iterator
    while dup 16 * memories   + !8 0 != do
        dup 16 * 2 pick + !8      # [ ptr iter ptr(ident) ]
        over 16 * 3 pick + 8 + !8 # [ ptr(procs) iter ptr(ident) mem_size ]


        swap cstr_to_str  # [ ptr(procs) iter mem_size len ptr(ident) ]
        add_instruction ": resb " print put

        1 +
    end
    "\n" print
    pop pop
end

proc main do
    # Test program
    # 69
    block 0  + push_op @8  
    block 8  + 69 @8 
    # 420
    block 16  + push_op @8  
    block 24  + 420 @8 
    ## swap
    block 32  + swap_op @8  
    ## put
    block 48 + put_op @8
    ## put
    block 64 + put_op @8
    ## syscall4
    block 80 + syscall_op @8
    block 88 + 4 @8
    ## +
    block 96 + infixOperators_op @8
    block 104 + infix_add @8
    ## load
    block 112 + store_op @8
    block 120 + 8 @8
    ## store
    block 128 + load_op @8
    block 136 + 8 @8

    memories 0 + "buffer_a" str_to_cstr @8
    memories 8 + 420 @8
    memories 16 + "buffer_b" str_to_cstr @8
    memories 24 + 13 @8


    # Include the beginning of the asm file
    include_asm_start

    # block compile_block

    
    procedures 0 + "main" str_to_cstr @8
    procedures 8 + block              @8
    
    compile_x86_64
end